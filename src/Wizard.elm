module Wizard exposing
  ( StepMsg(..), ServerMsg(..), Msg, Model, Check(..), Wizard, Step, View, ViewModel
  , wizard, embedMsg, forward, back
  )

{-| A module for building multi-step wizards with model validation at each step
to control progress.

@docs Check, Model

# Messages
@docs ServerMsg, StepMsg, Msg, forward, back, embedMsg

# The Wizard
@docs Wizard, Step, wizard

# Views
@docs View, ViewModel

-}

import Cons exposing (Cons)
import Html exposing (Html)
import List.Extra as List
import Maybe.Extra as Maybe
import Task


{-| Messages delivered to the steps.
-}
type StepMsg err msg
  = Msg msg
  | InvalidModel (List err)


{-| Private wizard messages.
-}
type Msg err msg
  = Forward
  | Back
  | StepMsg (StepMsg err msg)


{-| Messages returned to the component embedding the Wizard.
-}
type ServerMsg err msg model
  = WizardMsg (Msg err msg)
  | Completed model
  | Cancelled


{-| Result of model validation.
-}
type Check err
  = Ok
  | Failed (List err)


{-| A wizard model.
-}
type Model err msg model
  = Model
    { model : model
    , step : Step err msg model
    , left : List (Step err msg model)
    , right : List (Step err msg model)
    }


{-| `update` can generate `ServerMsg` messages which pass information about
completion or cancellation up to the embedding component.
-}
type alias Wizard err msg model
  = { init : Model err msg model
    , update : Msg err msg
             -> Model err msg model
             -> (Model err msg model, Cmd (ServerMsg err msg model))
    , view : Model err msg model -> Html (Msg err msg)
    }


{-| A step of a wizard.  A step's `update` function receives `StepMsg` messages
that can indicate that a check of the model failed.
-}
type alias Step err msg model
  = { update : StepMsg err msg -> model -> (model, Cmd msg)
    , view : model -> Html msg
    , check : model -> Check err
    }


{-| A view function for the wizard.  It has access to a model of the wizard, and
`Html` which the current step has generated that it can embed.  Forward and back
messages may be generated by a `View` function.
-}
type alias View err msg model
  = ViewModel model -> Html msg -> Html (Msg err msg)


{-| Model data that can be used for generating the wizard's view.
-}
type alias ViewModel model
  = { model : model
    , numSteps : Int
    , currentStep : Int
    }


{-| Build a wizard value.  It needs a view function to render the wizard
controls, a non-empty list of steps of the wizard, and the initial model.
-}
wizard : View err msg model
       -> Cons (Step err msg model)
       -> model
       -> Wizard err msg model
wizard render steps init =
  let model =
        Model
          { model = init
          , step = Cons.head steps
          , left = []
          , right = Cons.tail steps
          }
  in { init = model, update = update, view = view render }


{-| Return a value as a Cmd.
-}
command : a -> Cmd a
command x =
  Task.perform identity identity (Task.succeed x)


update : Msg err msg
       -> Model err msg model
       -> (Model err msg model, Cmd (ServerMsg err msg model))
update msg (Model model) =
  case msg of
    Forward ->
      case model.step.check model.model of
        Ok ->
          Maybe.mapDefault
            (Model model, command (Completed model.model))
            (\m -> (m, Cmd.none))
            (stepForward (Model model))
        Failed errs ->
          (Model model, command (WizardMsg (StepMsg (InvalidModel errs))))
    Back ->
      case stepBack (Model model) of
        Nothing ->
          (Model model, command Cancelled)
        Just m ->
          (m, Cmd.none)
    StepMsg m ->
      case model.step.update m model.model of
        (model', cmd) ->
          (Model { model | model = model' }, Cmd.map (Msg >> StepMsg >> WizardMsg) cmd)


view : View err msg model
     -> Model err msg model
     -> Html (Msg err msg)
view render (Model m) =
  let m' = { model = m.model
           , numSteps = List.length m.left + List.length m.right + 1
           , currentStep = List.length m.left
           }
  in render m' (m.step.view m.model)


{-| A message to move forward in the sequence of steps.
-}
forward : Msg err msg
forward =
  Forward


{-| A message to move backward in the sequence of steps.
-}
back : Msg err msg
back =
  Back


{-| Embed a `msg` into a `Msg`.
-}
embedMsg : msg -> Msg err msg
embedMsg =
  Msg >> StepMsg


--
-- ZIPPERS
--


stepForward : Model err msg model -> Maybe (Model err msg model)
stepForward (Model m) =
  List.uncons m.right |>
    Maybe.mapDefault
      Nothing
      (\(r, rs) -> Just (Model { m | step = r, left = m.step :: m.left, right = rs }))


stepBack : Model err msg model -> Maybe (Model err msg model)
stepBack (Model m) =
  List.uncons m.left |>
    Maybe.mapDefault
      Nothing
      (\(l, ls) -> Just (Model { m | step = l, left = ls, right = m.step :: m.right }))
